    <!-- Feature page-->
<div id="technology" class="page color-4">
    <div class="inner-page">
        <h2 class="page-headline">Technology</h2>
        <div class="row centered">
            <br />
            <br />
            <p>
                <ul class="container">
                    <li class="col-md-4">
                        <a href="#architecture" class="scroll btn btn-primary centered"><i class="fa fa-caret-down"></i> Architecture</a>
                    </li>

                    <li class="col-md-4">
                        <a href="#languages-tools" class="scroll btn btn-primary centered"><i class="fa fa-caret-down"></i> Languages &amp; Tools</a>
                    </li>

                    <li class="col-md-4">
                        <a href="#methodology" class="scroll btn btn-primary centered"><i class="fa fa-caret-down"></i> Methodology</a>
                    </li>
                </ul>
            </p>
        </div>
    </div>
</div>

<div id="architecture" class="page color-3">
    <div class="inner-page text-center">
        <h3>Architecture</h3>
        <hr />
        <div class="row justify">
            <p>
                I'm a practitioner of Domain Driven Design (DDD), Command Query Responsibility Segregation (CQRS), Event Sourcing (ES), Service Oriented Architecture (SOA),
                Event Sriven Architecture (EDA), microservices, and messaging principles. I'm a big believer in just enough design (which tends to be very little), and emergent architecture.
                Rather than making technology choices up front, I prefer to prototype and experiment, and gravitate towards approaches that keep the most options open until
                the last responsible moment. As a corollary, I prefer principles that provide small incremental value as opposed to large big-bang releases.
            </p>
            <p>
                I've seen a common theme in many clients attempting DDD, CQRS, Event Sourcing, SOA, etc. People tend to focus heavily on the technical details, and common
                superficial patterns. As a result, they miss out on the core values of the approaches. They tend to look for a cookie-cutter approach, often resulting in
                something similar to an n-layer architecture. This starts out well, but soon tends to result in features taking longer and longer to get delivered. Instead
                of trying to use the same patterns and practices regardless of requirements, I focus on identifying the ones that cater to a particular project's needs, and
                implement them with long term benefits in mind.
            </p>
            <p>
                I'm a fan of "living software". I believe that unforseen scenarios and requirements will emerge, and that it is impossible to get everything right from the
                get go. As such, I divide systems into contexts and services, and implement each to be as good as necessary. Applying the same level of dexterity to
                everything only results in overhead and accidental complexity. Instead, I reserve the most focus for the contexts that provide the highest return, while
                ensuring under-performing bits can be easily replaced. As such, my solutions evolve over time, rather than following a pre-destined failure-bound path.
                Whether I am putting together a large topology for high performance reliable brokerless messaging with ZeroMQ, capturing domain events in an event store, composing
                functions with reactive extensions, exchanging 10 million + messages in memory per second with plain old C#, hooking together distributed applications with a broker
                like RabbitMQ, evolving level 3 ReST services, applying messaging through process managers, routing slips and sagas, or doing simple CRUD with Entity Framework - I always keep the bigger picture in mind.
            </p>
        </div>
    </div>
</div>

<div id="languages-tools" class="page color-4">
    <div class="inner-page text-center">
        <h3>Languages and Tools</h3>
        <hr />
        <div class="row centered">
            <p>
                With over 12 years of professional experience, I've used a few things.
            </p>
        </div>
        <div class="row justify">
            <p>
                Most of my commercial experience has been with .NET, and C#. I've been with the platform since 2002, having used the public 1.0 beta. After briefly using WinForms,
                I quickly switched my focus onto WebForms, and then ASP.NET MVC as soon as it came out. Since then, I've delved into high performance scalable distributed server-side
                applications, while keeping a keen eye on client side technologies like ASP.NET MVC, Web API, jQuery, Knockout, AngularJS, bootstrap, etc. For message oriented systems, I've
                used ZeroMQ, RabbitMQ, Mass Transit, NServiceBus, Service Bus for Windows Server, and - where appropriate - chose to implement custom messaging for problems that haven't fallen into
                the gaps filled by existing tools. In the .NET world, I've also used WCF, WPF, Prism, NancyFx, Windows Services, TopShelf, Reactive Extensions for .NET, Silverlight, NHibernate,
                Entity Framework, Dapper, Simple.Data, ASMX Services, various IoC containers (including Autofac, Structuremap, Unity), NCqrs, CommonDomain, RIA Services, etc. As a fan of automated
                testing, I've used tools like NUnit, XUnit, Machine.Specifications, SpecFlow, Moq, FakeItEasy, FitNese,  and quite often create lightweight frameworks around NUnit for domain specific
                testing.
            </p>
            <p>
                As mentioned before, most of my commercial experience has been with C#, and I'm more than at home with JavaScript. I am, however, interested in a broad range of languages.
                I've passed professional courses at Oxford University on Haskell and Erlang with distinction, and have completed Coursera training courses on Scala and R with 100% marks.
                I'm very keen on functional programming, and look to use F# wherever appropriate. In fact, most C# I write these days is heavily influence by functional programming concepts.
                I'm learning Python and Octave / Matlab as I get deeper into Machine Learning. Although it's been a while, I used to code quite a bit of C++ as well - from taking part in
                programming contests, to writing 2D and 3D engines on top of DirectX 7-9.
            </p>
            <p>
                I'm a follower of Continuous Integration and Continuous Delivery. I build build scripts using Psake, MSBuild, etc., and my CI server of choice is Team City, though I have experience
                with Jenkins and TFS as well. I'm using tools like Puppet and Vagrant to take advantage of reproduceable environments, and am a fan of productivity tools like ReSharper, MightyMoose, etc.
            </p>
            <p>
                I'm a relentless learner, and love to pick up new things. I like being out of my comfort zone, and am currently learning more of Erlang, Haskell, Scala, Node.js, Hadoop, Riak, Cassandra...
                I often sign up for online courses covering topics like Cryptography, Data Analysis, etc. that I find interesting and challenging. Sometimes I attend professional training courses. For example,
                I've been through Martin Thompson's Lock Free Algorithms and Jezz Humble's Continuous Delivery workshops. I have an extensive collection of books - from Joe Armstrong's latest Erlang writings
                to Gul Agha's works on Actor Models going back decades.
            </p>
        </div>
    </div>
</div>

<div id="methodology" class="page color-3">
    <div class="inner-page text-center">
        <h3>Methodology</h3>
        <hr />
        <div class="row centered">
            <p>
                Agile, without the capital 'A'.
            </p>
        </div>
        <div class="row justify">
            <p>
                I've seen quite a few clients struggle with Agile. They have their people go to certification courses, make managers "scrum masters", set up rigorous processes, arrange
                planning meetings, reviews, and retrospectives. Yet they seem to have trouble where it matters - actually delivering software. In the formalisation of Agile, we seem to
                have lost what it stands for. We seem to value processes and tools over individuals and interactions. We try to create templates to be used in all projects, and try to
                plan away risk. We attempt to prevent failure, rather than learning from experiments. We hold onto the same practices of yesterday, but expect that with the addition of
                some meetings, a task board, and some sharpies - everything will get better on its own.
            </p>
            <p>
                The value of agile or lean is not in the process, or estimations, or burndown charts. While these things can be useful, the core revolves around continuously delivering
                working software, and having working software as the measure of progress. Tightening the feedback loop not only gives us faster feedback, it also reduces risk and prevents
                us from veering off course. The process should facilitate software deliver, not the other way round. Different projects have different needs - trying to enforce the same
                processes across the board may seem like an efficient, repeatable option - yet it is one that can cripple the actual act of providing value. Instead of delivering value, 
                Agile (with the capital 'A') turns into a hindrance that the team has to bear to keep management happy.
            </p>
            <p>
                There are certain practices that are invaluable in sustainable and frequent software delivery. Continuous integration, efficient version control, push-button deployments,
                phoenix servers, high quality tests, refactoring where arppropriate, evolvable architecture, impact mapping, early risk identification, prototyping for solutions, pair
                programming, etc. canall help in creating releasable, production ready software that not only works, but evolves when necessary. These may seem technical, yet are fundamental
                in attaining the benefits of lean and agile methodologies. Guess what I tend to focus on?
            </p>
        </div>
    </div>
</div>


<!-- /#features -->
